---
title: "R语言编程篇——面向函数的编程"
date: 2019-07-13
categories:
  - R语言
  - 编程
tags:
  - R语言编程
keywords:
  - R语言
  - 面向函数的编程
thumbnailImagePosition: left
thumbnailImage: https://i.postimg.cc/Y9XvNgPJ/image.png
---

**面向函数的编程**。

<!--more-->

<!-- toc -->

## 1、函数的几种执行环境

我们在之前的文章中介绍过，函数有四种不同的执行环境： *存储环境*（存储函数的执行环境）， *定义环境*（函数定义时的执行环境）， *调用环境*（函数调用时的执行环境）， *内部环境*（函数内部的执行环境）。

存储环境与定义环境在绝大多数情况下是一致的，但两者并非必然相同，从如下代码中可知，存储环境取决于函数存储在什么执行环境中，而定义环境取决于生成函数的命令（`function(){}`）在什么执行环境中执行。

```R
# 函数存储在全局执行环境中，定义环境也是全局执行环境
> f <- function(){}; environment(f)
<environment: R_GlobalEnv>

# 定义一个新的执行环境
> e <- new.env(parent = baseenv()); e
<environment: 0x56374488d210>
# 函数存储在新执行环境e中，定义环境也是e
> assign("f", evalq(function(){}, e), pos = e); environment(e$f)
<environment: 0x56374488d210>
# 函数存储在新执行环境e中，但定义环境是全局执行环境
> assign("f", function(){}, pos = e); environment(e$f)
<environment: R_GlobalEnv>
```

我们知道函数的参数列表是以**延时命令**的形式存储的，只有当参数被使用到时才会计算对应的取值。正是如此才使得定义环境显得如此重要，比如以下代码中，函数**f**被定义后，参数列表中的参数**e1**并没有被立即替换为变量**a**的值，而是以**延时命令**的形式存储了变量名**a**及其所在执行环境。所以这里先定义**a**再定义**f**，与先定义**f**再定义**a**效果是一样的。函数**f**被调用时，会在定义环境中寻找**a**的值，并将其传递给参数**e1**，所以此时不需要指定任何参数，函数也可以被调用。而如果我们在执行环境**e**中执行定义函数**f**的命令，调用时则会遇到类似{{< hl-text red >}}找不到对象'a'{{< /hl-text >}}的错误。

```R
# 在定义环境中生成变量a
> a <- 123
# 参数列表中的变量a并没有被直接替换为123
> assign("f", function(e1 = a, e2 = 0) e1 + e2, pos = e); e$f
function(e1 = a, e2 = 0) e1 + e2
# e中没有变量a，但函数依然可以被调用
> evalq(f(), e)
[1] 123

# 定义环境中没有变量a
> evalq(f <- function(e1 = a, e2 = 0) e1 + e2, e); e$f()
Error in e$f() : 找不到对象'a'
```

我们之前介绍过全局执行环境与程序包执行环境之间的关系，它们之间拥有继承关系，并且可以通过序号获取相应的执行环境。类似的，函数每次被调用都会生成一个特定的内部环境，而且嵌套调用、内部调用、递归调用时产生的内部环境之间存在某种可以用 *序号* 表示的关系，序号的大小是按照函数被调用的先后顺序决定的。我们也可以将这种关系理解为函数压栈，第一个压栈的函数序号为1，之后每个压栈的函数序号都会增加1，而全局执行环境的序号总是为0。

我们可以在函数体中使用{{< hl-text primary >}}sys.nframe{{< /hl-text >}}函数，在函数被调用时查看当前函数对应的序号。

```
# 函数每次被调用都会生成新的内部环境
> f <- function()sys.frame(sys.nframe())
> f(); f()
<environment: 0x563744ed9d20>
<environment: 0x563744ed62e0>

# 第一个压栈的函数序号为1，之后每个压栈的函数序号加1
> f <- function(n)if(n > 0) f(n - 1) else sys.nframe()
> c(f(0), f(1), f(2))
[1] 1 2 3
```

内部环境的父执行环境往往是调用环境，比如在全局执行环境中调用的函数，其内部环境的父执行环境是全局执行环境，而在函数内部调用的函数，其内部环境的父执行环境总是父函数的内部环境。但分发函数是个例外，因为分发函数调用了被分发函数，但两者内部环境的父执行环境是一样的。

我们可以在函数体中使用{{< hl-text primary >}}sys.parent(n = 1){{< /hl-text >}}的形式，查看当前压栈的函数内部执行环境的父执行环境所对应的序号，若n为2，则是内部执行环境的父执行环境的父执行环境所对应的序号。也可以使用{{< hl-text primary >}}sys.parents{{< /hl-text >}}函数，查看每个压栈的函数内部执行环境的父执行环境所对应的序号。

```R
# 内部环境的父执行环境往往是调用环境
> f <- function(n)if(n > 0) f(n - 1) else sys.parent()
> c(f(0), f(1), f(2))
[1] 0 1 2

# 被分发函数内部环境的父执行环境与调用环境不同
> f <- function(x){
+   cat("调用环境            ：")
+   print(sys.nframe())
+   UseMethod("f", x)
+ }
> f.foo <- function(x){
+   cat("内部环境的父执行环境：")
+   print(sys.parent())
+ }
> a <- structure(pi, class = "foo")
> f(a)
调用环境            ：[1] 1
内部环境的父执行环境：[1] 0
```

<br>

## 2、从函数内部获取函数信息


sys.nframe()              函数所处执行环境，第几个压栈
sys.frame(which = 0)      函数执行环境，每个函数压栈就新生城一个执行环境，全局执行环境永远为0
sys.call(which = 0)       调用函数的命令
sys.function(which = 0)   函数体
sys.parent(n = 1)         上一个压栈的函数的位置

sys.frames()
sys.calls()
sys.status()
sys.parents()
sys.on.exit()             on.exit函数中的命令

parent.frame(n = 1)

- 全局执行环境的压栈位序始终为0，每个压栈的函数，内部执行环境位序加1
- 内部执行环境的父环境是函数被调用时的执行环境，print(f(...)) 两个函数内部执行环境的父环境都是全局执行环境
- print(f(...)) 两个函数都是在全局环境中被调用的，但print是第一个压栈的，f是第二个压栈的
- 每次调用函数会新生成一个函数内部执行环境，函数执行完毕即实效，记录被赋值的变量
- 取出函数内部执行环境：sys.frame(sys.nframe())，取出上层压栈的执行环境：parent.frame()
- which为零或正数代表从全局执行函数开始，向上寻找多少个压栈的执行环境。为负数表示从当前压栈的执行环境开始，向前寻找多少个压栈的执行环境
- sys.parent中的n为1则返回上一个压栈的执行环境序号，为2则返回上上一个，以此类推
- which为正数表示压栈序号，为负数表示从当前压栈序号向上翻多少层，为0时表示当前序号，但sys.parent(0)表示全局变量

- sys.nframe避免压栈过多超出内存

<br>

## 3、参数列表

...
missing、match.args
stopifnot


<br>

## 4、函数的返回值

return
stop
on.exit

<br>

## 下一篇

- debug
- S3函数分发
- S4、R6类型的对象
- 文件资源管理
- 网络资源管理

{{< note "思考思考" "#e6e6ff" >}}
- ？

{{< /note >}}

<br>
