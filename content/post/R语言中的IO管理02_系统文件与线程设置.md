---
title: R语言中的系统文件与线程设置
date: 2019-09-16
categories:
  - R语言
  - IO管理
tags:
  - R语言IO管理
keywords:
  - R语言
  - IO管理
  - 系统文件
  - 线程设置
thumbnailImagePosition: left
thumbnailImage: https://s2.ax1x.com/2019/09/22/uShTE9.png
---

一门脚本语言往往需要依赖**系统文件** *持续化* 内存中的各类内容，或者向内存中 *初始化* 某些内容（即对当前线程进行个性化设置）。这篇文章我们将介绍R语言中的系统文件与线程设置。

<!--more-->

<!-- toc -->

<br>

## 1、系统文件输入输出

R语言中的系统文件可以被用于保存**R语言代码**、**数据**、**历史记录**、**线程设置**等内容，存储不同类型的内容需要用到不同类型的系统文件。这些系统文件的后缀名可以是任意的，但是不同类型的系统文件拥有相应的默认后缀名。以下便是根据默认后缀名划分的，R语言中各类系统文件的功用：

| 文件后缀        | 解释说明            
|:----------------|:------------------------------------------------------------------------
| .R              | 保存R语言代码
| .Rout           | 保存批处理模式下R语言代码执行后的输出内容
| .Rhistory       | 保存R语言历史记录
| .Rproj          | 保存R语言工程相应的设置
| .rds            | 存放序列化后的R语言对象取值（单个对象，不包含对象名）
| .rdx            | 存放序列化后的R语言对象取值，可能是被压缩处理后的.rds文件
| .rda            | 保存单个对象，包含变量名及取值，常用于程序包
| .RData          | 保存一个或多个对象，包含变量名及取值
| .rd             | 原帮助文档，相当于格式固定的文本文档，需要程序包开发者逐一编写其中内容
| .rdb            | 编译后的帮助文档，已经被序列化
| .site           | 系统配置文件

<br>

### 1.1、输入输出R语言代码

我们知道在R语言中可以使用{{< hl-text primary >}}source{{< /hl-text >}}函数执行R语言脚本，同时我们也可以使用{{< hl-text primary >}}dump{{< /hl-text >}}函数，将执行结果反向转化为R语言代码存储在脚本文件中。

```R
> a <- women[1, ]
> dump("a", file = "")
a <-
structure(list(height = 58, weight = 115), row.names = 1L, class = "data.frame")
```

我们之前在 [R语言编程篇——面向语言的编程](../../06/r语言编程篇面向语言的编程/)一文中介绍了如何使用**parse、deparse**等函数转化R语言代码与字符串。这里介绍的**dump**函数在底层调用了**deparse**函数，所以实际上**deparse**函数不只可以将代码转化为字符串，也可以将代码执行结果反向解析为字符串类型的代码。

<br>

### 1.2、输入输出R语言历史记录

默认情况下，R语言会在当前工作目录下建立一个**.Rhistory**文件，用于保存使用者在R语言命令行下的操作记录。注意这里的历史记录只保存执行过的R语言代码，而不会保存代码执行结果。我们可以在R语言命令行下使用上下方向键翻越历史记录，或者使用**RStudio**的历史记录窗格管理历史记录。

保存与管理历史记录，可以帮助我们大量节省反复输入代码的时间。在R语言中，我们可以分别使用{{< hl-text primary >}}savehistory、loadhistory{{< /hl-text >}}函数保存、载入历史记录，使用{{< hl-text primary >}}history{{< /hl-text >}}函数查找历史记录，使用{{< hl-text primary >}}timestamp{{< /hl-text >}}函数在历史记录中插入一条时间分界线。

<br>

### 1.3、输入输出R语言对象

#### 1.3.1、数据序列化

在总结输入输出R语言对象的方法之前，我们首先需要了解R语言中的**序列化**过程。序列化指的是一门计算机语言，将内存中的对象按照一定的模式，转换为可以存储或传输的形式的过程。在R语言中，我们可以分别使用{{< hl-text primary >}}serialize、unserialize{{< /hl-text >}}函数，序列化、反序列化对象。

R语言中的序列化可以分为两种模式——**字节型**和**ascii字符型**，前者会R语言中的数据对象及相应的信息（对象的数据类型，数组长度，系统编码等）以转化为字节，而后者则将这些信息转化为ascii字符。此外两者分别会在序列化结果的起始位置，以二进制的形式输出字符**X**、**A**，所以很容易根据序列化结果区分两种模式。

```R
> cat(rawToChar(serialize(123, connection = NULL, ascii = T)))
A         # 以ascii字符型的模式进行的序列化
3
198145
197888
5
UTF-8     # 序列化时的编码
14        # 数据类型，14表示浮点型数组
1         # 数组长度
123       # 数据，以ascii字符的形式存储（三个字节），而非以浮点型数字的形式存储
```

<br>

#### 1.3.2、输入输出单个R语言对象对应的取值

我们可以分别使用{{< hl-text primary >}}saveRDS、readRDS{{< /hl-text >}}函数，将单个R语言对象对应的取值序列化写入文件、或从文件中反序列化读入。这种方式与序列化的过程几乎一致，不同的时这里在写入文件时可以进行压缩（参考**saveRDS**函数的**compress**参数）。程序包中的数据对象大多以这种方式存储，文件后缀名一般为**.rds、.rdx**。

<br>

#### 1.3.3、输入输出R语言对象

如果我们需要保存一个或多个R语言对象，并将对象名与取值一同保存起来，则可以使用{{< hl-text primary >}}save、save.image{{< /hl-text >}}函数。前者需要我们指定保存哪些变量，而后者则直接保存整个**工作空间**（**workspace**，即全局执行环境中的所有内容）。

R语言线程在结束时，一般会询问使用者是否保存工作空间，除非在线程启动时进行了相应的设置。此时如果我们选择保存工作空间，全局执行环境中的所有内容，都会被保存在当前工作路经下的**.RData**文件中，相当于调用了**save.image**函数。

我们可以使用{{< hl-text primary >}}load{{< /hl-text >}}函数，从保存R语言对象的文件（ *数据文件* ）中读取数据，其**envir**参数还可以选择将读取的数据存放在哪个执行环境中。此外我们还可以分别使用{{< hl-text primary >}}attach、detach{{< /hl-text >}}函数，像载入、脱载程序包一样，载入、脱载这样的数据文件。

<br>

## 2、线程设置

R语言中的**系统文件**与**线程设置**是紧密相关的，这些系统文件常被R语言线程用于保存历史记录、恢复上一次使用状态。我们可以在R语言启动的时候，对当前线程进行个性化配置，从而决定哪些系统文件需要被使用、哪些操作需要初始化等。

<br>

### 2.1、R语言线程启动参数

在命令行（**bash**、**CMD**等）下启动R语言时，我们可以设置一系列的**启动参数**，从而决定R语言线程的工作方式。我们可以在R语言中使用{{< hl-text primary >}}commandArgs{{< /hl-text >}}函数，查看当前线程的启动参数。以下是部分常用R语言启动参数：

| 参数选项              | 解释说明            
|:----------------------|:------------------------------------------------------------------------
| -h, --help            | 打印命令行启动R语言时的帮助信息并退出
| --version             | 打印R语言版本信息并退出
| RHOME			            | 打印R语言安装目录并退出
| --no-environ          | 当前线程启动时，不要读取系统或用户**environ**文件
| --no-site-file        | 当前线程启动时，不要读取系统**profile**文件
| --no-init-file        | 当前线程启动时，不要读取用户**profile**文件
| --save                | 当前线程结束时，保存工作空间
| --no-save             | 当前线程结束时，不保存工作空间
| --restore             | 当前线程启动时，从保存R语言对象的文件（**.RData**）中恢复工作空间
| --no-restore-data     | 当前线程启动时，不要恢复工作空间
| --no-restore-history  | 当前线程启动时，不要恢复历史记录
| --no-restore          | 当前线程启动时，不要恢复工作空间或历史记录
| --vanilla		          | 相当于 --no-save --no-restore --no-site-file --no-init-file --no-environ
| -q, --quiet, --silent | 当前线程启动时，不打印起始提示信息
| --slave               | 当前线程启动及运行时，尽可能少的输出提示信息
| --verbose             | 当前线程启动及运行时，尽可能详细的输出提示信息
| -f FILE, --file=FILE  | 在R语言中执行 **FILE** 对应文件中的R语言代码并退出
| -e EXPR               | 在R语言中执行 **EXPR** 并退出
| --args                | 忽略**--args**之后的命令行参数
| --encoding=ENC, --encoding ENC | 设置R语言系统输入的编码，默认为系统编码

除了交互式运行，R语言也可以在批处理模式下运行。比如我们可以使用启动参数**-f**、**-e**，但此时批处理的结果会直接打印在命令行中。如果我们需要保留运算结果，则可以使用`R CMD BATCH [options] infile [outfile]`的形式。此时只要我们提供R语言脚本作为输入文件（**infile**），R语言就会把代码执行后的输出内容存入输出文件（**outfile**）中。注意默认的**outfile**与**infile**的文件名相同，但后缀名为**.Rout**。

<br>

### 2.2、R语言线程起止过程

R语言线程启动和退出时，会进行一系列默认的起始化/终止化操作，当然这些操作步骤大多数都可以根据使用者的喜好选择性的执行。比如，如果我们设置了启动参数**--save**，则当前线程结束时，不会询问使用者是否保存工作空间，而是直接将工作空间保存在工作目录下的**.RData**文件中。

- 启动R语言线程
  - 读取系统**environ**文件：寻找环境变量**R_ENVIRON**，如果找不到则默认为**R_HOME/etc/Renviron.site**，如果文件存在则读取。注意这里的**R_HOME**指的是R语言安装时的根目录，可以在R语言中使用{{< hl-text primary >}}R.home{{< /hl-text >}}函数获取。**environ**文件相当于当前线程的配置文件，必须以`变量名=取值`的形式配置环境变量（比如`R_ENVIRON_USER="~/.Renviron"`），其中的注释格式与R语言相同，但不能包含R语言代码。
  - 读取用户**environ**文件：寻找环境变量**R_ENVIRON_USER**，如果找不到则先后从当前文件夹、用户主目录中寻找**.Renviron**文件，如果文件存在则读取。
  - 读取并执行系统**profile**文件：寻找环境变量**R_PROFILE**，如果找不到则默认为**R_HOME/etc/Rprofile.site**，如果文件存在则读取并执行其中的R语言代码。**profile**文件相当于当前线程的起始化设置文件，其本质上仍是R语言脚本。但需要注意的是，**profile**文件中的代码被执行时当前线程只载入了**base**程序包。
  - 读取并执行用户**profile**文件：寻找环境变量**R_PROFILE_USER**，如果找不到则先后从当前文件夹、用户主目录中寻找**.Rprofile**文件，如果文件存在则读取并执行其中的R语言代码。
  - 载入工作空间：在当前工作目录下寻找**.RData**文件，如果文件存在则载入。
  - 载入历史记录：寻找环境变量**R_HISTFILE**，如果找不到则默认为当前目录下的**.Rhistory**文件，如果文件存在则载入。
  - 在R语言中寻找**.First**函数（可以在**profile**文件中配置），如果存在则执行`.First()`。
  - 执行**base**程序包中的**.First.sys**函数，载入默认的系统程序包（`options("defaultPackages")`）。当然我们也可以在**environ**文件修改环境变量**R_DEFAULT_PACKAGES**，来设置需要自动载入的程序包。
  
  
- 退出R语言线程
  - 询问是否保存工作空间，如果使用者选择保留工作空间（`q("yes")`），则将工作空间保存在工作目录下的**.RData**文件中。
  - 在R语言中寻找**.Last**函数，如果存在则执行`.Last()`。
  - 删除工作空间，脱载程序包，结束当前线程。

<br>

### 2.3、R语言中的系统变量

上文中我们介绍了如何在**environ**文件中设置**环境变量**，我们可以使用{{< hl-text primary >}}readRenviron{{< /hl-text >}}函数读取**environ**文件中的环境变量，也可以在R语言中分别使用{{< hl-text primary >}}Sys.getenv、Sys.setenv、Sys.unsetenv{{< /hl-text >}}函数，查询、设置、删除环境变量。这些操作都是直接调用底层语言完成的，所以说这里的环境变量并非R语言层面的变量（我们无法在任何执行环境中找到这些变量），所以这些环境变量的取值只能是字符串。

除了上文介绍过的环境变量，R语言中还存在许多其它的系统环境变量，用于配置当前线程的各项参数、决定当前线程的工作方式。比如，环境变量**LC_ALL**主要用于设置**系统区域**信息，该值为空时R语言中的系统区域信息与操作系统中的相同。我们也可以分别使用{{< hl-text primary >}}Sys.getlocale、Sys.setlocale{{< /hl-text >}}函数，查询、设置这些系统区域信息。要了解更多环境变量及其作用，请参考**EnvVar**的帮助文档。

```R
# 设置配置变量R_TEST
> Sys.setenv(R_TEST = "testit")
# 查询配置变量R_TEST
> Sys.getenv("R_TEST")
[1] "testit"
# 删除配置变量R_TEST
> Sys.unsetenv("R_TEST")
# 查询配置变量R_TEST
> Sys.getenv("R_TEST", unset = NA)
[1] NA
```

与环境变量十分类似的是R语言中的**配置变量**，我们可以在R语言中分别使用{{< hl-text primary >}}options、getOption{{< /hl-text >}}函数，查询、设置、删除配置变量。与环境变量不同的是，配置变量是R语言层面的变量，它们都存储在**base**程序包中的**.Options**变量中。

我们曾在之前的文章中多次使用过配置变量，比如使用配置变量**digits**决定浮点型数值的精确度，使用配置变量**prompt**决定R语言中的命令提示符。要了解更多配置变量及其作用，请参考**options**的帮助文档。

```R
# 设置配置变量R_TEST
> options(R_TEST = "testit")
# 查询配置变量R_TEST
> options("R_TEST")
$R_TEST
[1] "testit"
# 删除配置变量R_TEST
> options(R_TEST = NULL)
# 查询配置变量R_TEST
> getOption("R_TEST", default = NULL)
NULL
```

<br>


{{< note "思考思考" "#e6e6ff" >}}
- 如何在R语言中读取后缀名默认为**.rdb**系统文件？
- R语言序列化结果其余部分分别有什么意义？
- R语言线程启动时，如何在读取系统**environ**文件之前，配置环境变量**R_ENVIRON**？

{{< /note >}}

<br>
