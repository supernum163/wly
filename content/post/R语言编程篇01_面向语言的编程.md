---
title: "R语言编程篇——面向语言的编程"
date: 2019-06-28
lastmod: 2019-07-18
categories:
  - R语言
  - 编程
tags:
  - R语言编程
keywords:
  - R语言
  - 面向语言编程
thumbnailImagePosition: left
thumbnailImage: https://i.postimg.cc/V6vCjVv9/image.png
---

在上一篇文章中，我们已经介绍了R语言**元编程**的基础——命令与执行环境，灵活运用这些基础对象，可以使我们的编程效率事半功倍。这篇文章我们将归纳总结R语言中元编程的基本模式与运用技巧。

<!--more-->

<!-- toc -->

作为一门实时交互的脚本语言，在R语言中输入的代码总是会被立即执行，所以我们往往只能得到代码运行结果。但有的时候我们不希望代码被立即执行，而是想要先捕获代码，然后在特定的条件下再执行代码。

比如以下代码我们从**mtcars**数据集中筛选出了**hp**等于**110**的数据，注意这里我们在{{< hl-text primary >}}subset(){{< /hl-text >}}函数中传入了命令`hp == 110`。如果我们直接在命令行中执行这条命令一定会遇到类似这样的错误：<font color="#FF0000">找不到对象'hp'</font>。但这条命令却可以被**subset**函数直接运用，原因就在于**subset**函数捕获了这条命令，并在合适的执行环境中运用了这条命令。

```R
> subset(mtcars, hp == 110)
                mpg cyl disp  hp drat    wt  qsec vs am gear carb
Mazda RX4      21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag  21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
```

R语言中大量的函数都使用了这种编程理念，也正是因为这种理念才使得整个语言体系更加灵活。

<br>

## 1、生成命令与执行命令

我们可以使用{{< hl-text primary >}}call{{< /hl-text >}}函数构建一个命令（**function call**），其第一个参数必须是一个字符串，指明需要被构建的命令，其余参数都会被传递给新生成的命令。注意这里生成的命令与我们直接输入的命令不同，因为直接输入命令往往会得到运行结果，而这里生成的是命令本身，或者说是未被执行的命令。

上一篇文章中我们介绍过，命令可以被解析为指令树。反之我们也可以自己构建一个指令集，并将其转化为命令。我们只需要生成一个列表，将函数或者函数名作为列表的第一个元素，将函数的各参数作为列表的其余元素，同理用子列表的形式生成子命令对应的指令树，最后调用{{< hl-text primary >}}as.call{{< /hl-text >}}函数即可将指令集转化为命令。反之的我们也可以向操作指令集一样操作命令。

```R
# 生成命令
> call("+", 1:9, 1)
1:9 + 1

# 从指令集生成命令
> as.call(list(as.name("+"), 1:9, 1))
1:9 + 1
```

我们也可以使用{{< hl-text primary >}}do.call(what, args, quote = FALSE, envir = parent.frame()){{< /hl-text >}}的形式在特定的执行环境（**envir**）中构建并直接执行命令，其中：被构建的函数可以是一个字符串或者一个函数名，若为字符串则可以在**envir**中查找相应的函数；**args**参数是被构建函数的参数列表，注意这里没有使用*...*编成，所以我们向调用的函数传参时，必须构建一个列表型数据。 

```R
# 直接调用函数
> do.call(`+`, list(1:9, 1))
[1]  2  3  4  5  6  7  8  9 10

# 被调用函数是字符串，会在新执行环境中查找该函数
> e <- new.env(); assign("f", function(a, b) a + b, pos = e)
> do.call("f", list(1:9, 1), envir = e)
[1]  2  3  4  5  6  7  8  9 10
```

我们还可以在函数体中，使用{{< hl-text primary >}}Recall{{< /hl-text >}}函数调用函数本身， 这对于递归函数，尤其是无名函数递归十分重要。如下代码中，我们使用无名递归计算了10的阶乘。

```R
# 无名函数递归
> (function(n){
+   if(n <= 1) return(1)
+   n * Recall(n - 1)
+ })(10)
[1] 3628800
```

<br>

## 2、捕获代码

我们可以使用{{< hl-text primary >}}quote{{< /hl-text >}}函数捕获未执行的代码，也可以使用{{< hl-text primary >}}enquote{{< /hl-text >}}函数捕获代码的运行结果。

```R
# 捕获未执行的代码
> quote(1:9 + 2)
1:9 + 2

# 捕获代码的运行结果
> enquote(1:9 + 2)
base::quote(c(3, 4, 5, 6, 7, 8, 9, 10, 11))
```

有时候我们希望捕获的代码中，某些变量名被替换成对应的值，因为如果在新的执行环境中执行捕获的代码，可能找不到这些变量的值。此时我们就可以使用{{< hl-text primary >}}substitute(expr, env){{< /hl-text >}}的形式。注意**substitute**函数除了需要捕获的代码，还可以传递一个替换环境**env**（可以是列表或者执行环境）参数，此时代码中的变量名如果在**env**中有对应的值，则会被替换为相应的值，除非**env**是全局执行环境。

如果我们只希望特定的变量名可以被替换，而非所有在执行环境中存在的变量都会被替换，则可以使用{{< hl-text primary >}}bquote{{< /hl-text >}}函数，该函数定义了一种特殊的语法格式——所有被包含在**.()**中的变量名才会被替换。

```R
# 捕获代码，在执行环境中给定需要替换的变量
> substitute(a + b, list(b = 1))
a + 1
> substitute(a + b, baseenv())
.Primitive("+")(a, b)

# 捕获代码，通过代码标明需要替换的变量
> bquote(x <- .(x) + 1, list(x = 1:9))
x <- 1:9 + 1
```

<br>

## 3、执行代码

我们可以使用{{< hl-text primary >}}eval(expr, envir, enclos){{< /hl-text >}}的形式执行捕获的代码，其中**envir**是代码中变量名的首要查找位置，**envir**中查找不到的变量名会在**enclos**中查找。

捕获代码与执行代码的过程是一一对应的，每调用一次**quote/substitute**函数，就需要多调用一次**eval**函数，最终才能取出执行结果。但需要特别注意的是：字面值无论被执行还是被捕获，结果依然是字面值；由操作符{{< hl-text primary >}}~(expr, envir, enclos){{< /hl-text >}}构成的命令，被捕获或执行后结果是一致的，唯一的区别在于**～**被捕获后产生的结果没有属性（**attributes**）部分，但无论何种情况我们可以像操作指令集一样取出**~**前后的内容，所以**~**经常被用作捕获代码的便捷操作符号；命令集（**expression**）本身就是未被执行的命令的集合，所以被捕获之后生成的是一个生成该命令集的命令，需要被执行两次才能取出执行结果。

```R
# 字面值无论被执行还是被捕获，结果依然是字面值
> c(quote(123), eval(123))
[1] 123 123

# 由“~”构成的命令，被捕获或执行后结果一致
> str(y ~ x)
Class 'formula'  language y ~ x
  ..- attr(*, ".Environment")=<environment: R_GlobalEnv> 
> str(quote(y~x))
 language y ~ x
 
# 命令集被捕获后需要被执行两次才能取出执行结果
> eval(eval(quote(expression(a <- 1:9, a+1))))
[1]  2  3  4  5  6  7  8  9 10
```

此外R语言中还存在许多快捷函数，它们巧妙的运用了执行环境与捕获、执行代码等函数，使得实际使用的过程中各有不同的意义，比如：

- {{< hl-text primary >}}evalq{{< /hl-text >}}函数相当于`eval(quote(expr), ...)`，可以直接让代码在特定的执行环境下运行，主要用于为代码中尚不存在的变量提供一个取值环境，以及避免底层执行环境覆盖了父执行环境中的变量等情况。
- {{< hl-text primary >}}eval.parent{{< /hl-text >}}函数即在 *父执行环境* 中执行捕获的命令，可以用于函数调用函数执行环境中的值，或内部函数调用父函数中的值。
- {{< hl-text primary >}}local{{< /hl-text >}}函数默认情况下会在一个临时执行环境中执行代码，可以有效的舍弃运算过程中产生的中间变量。


```R
# 将list(a = 1:9)作为执行环境，并执行a + 1
> evalq(a + 1, list(a = 1:9)) 
[1]  2  3  4  5  6  7  8  9 10

# 在baseenv中寻找pi的值，避免被全局变量中的pi值覆盖
> pi <- 1:9
> evalq(pi, baseenv())        
[1] 3.141593

# 函数中调用父执行环境中的值
> a <- 1:9
> (function() {
+     a <- a + 1
+     eval.parent(as.name("a"))
+ })()
[1] 1 2 3 4 5 6 7 8 9

# 在临时执行环境中执行代码，中间变量a会被自动舍弃，但可以取得运算结果
> local({a <- 1:9; a + 1})    
[1]  2  3  4  5  6  7  8  9 10   
```

<br>

## 4、字符串与代码互相转化

我们知道在R语言中可以使用{{< hl-text primary >}}source{{< /hl-text >}}函数在命令行中执行R语言脚本，同样的我们也可以使用{{< hl-text primary >}}parse{{< /hl-text >}}函数从字符串/字符串数组，文件或者命令行输入中解析代码。如此一来，我们便可以将字符串处理的技巧纳入到编程体系中来。

```R
# 从文件中解析代码，test.R中的内容如下：
# if(!exists("a"))
#   a <- 1:9
# a + 1
> parse(file = "docs/test_inline.R", n = 1)     # n = 1 表示只解析一条命令
expression(if(!exists("a"))
  a <- 1:9)

# 从字符串数组中解析代码
> parse(text = c("a <- 1:9", "a + 1"))
expression(a <- 1:9, a + 1)
  
# 从命令行输入中解析代码
> parse(prompt = ">> ")                         # 使用prompt重写命令提示符
>> a <- 1:9                                     # 在命令行中输入需要解析的字符串
expression(a <- 1:9)
```

为了方便从字符串中解析代码，新版本的R语言（**R 3.6.0**）中还添加了两个便捷函数{{< hl-text primary >}}str2lang、str2expression{{< /hl-text >}}。两者的不同之处在于：**str2lang**只能解析单个字符串，解析结果为命令；**str2expression**可以解析单个字符串或字符串数组，解析结果为命令集。

```R
# 将单个字符串解析为命令
> str2lang("a <- 1:9")
a <- 1:9

# 将字符串数组解析为命令集
> str2expression(c("a <- 1:9", "a + 1"))
expression(a <- 1:9, a + 1)
```

如果我们需要将代码转化为字符串，则可以使用{{< hl-text primary >}}deparse{{< /hl-text >}}函数。我们在使用**plot**函数绘图时，以命令形式提供的横纵坐标之所以可以显示为坐标轴标签，实际上就是因为**plot**函数底层运用到了**deparse**函数。

```R
# 将代码转化为字符串
> deparse(y ~ a * x + b)
[1] "y ~ a * x + b"
```

<br>

{{< note "思考思考" "#e6e6ff" >}}
- **enquote**函数的意义何在？
- **do.call**函数中的**quote**参数是设计败笔吗？
- 对于**do.call**函数，如何让**args**参数中的变量在**envir**参数对应的执行环境中查找，而非在**do.call**被调用的执行环境中查找？

{{< /note >}}

<br>
