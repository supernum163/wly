---
title: "R语言编程篇——函数分发"
date: 2019-08-01
categories:
  - R语言
  - 编程
tags:
  - R语言编程
  - R语言数据类型
keywords:
  - R语言
  - 函数分发
thumbnailImagePosition: left
thumbnailImage: https://i.postimg.cc/KYSrkmvQ/image.png
---

不同类型的数据需要不同的处理方式，我们要实现某一类效果，往往需要根据特定类型的数据编写相应的函数，但我们可能希望像使用同一个函数一样使用这些函数（因为它们实现的效果是类似的），此时就需要用到**函数分发**机制。这篇文集我们将介绍R语言中函数分发的规则。

<!--more-->

<!-- toc -->

在R语言的函数分发体系中，负责根据数据类型将参数分配给特定函数的是**分发函数**(**generic-function**)，而负责实现某一项具体功能的是**方法**（**method**）。


## 1、S3函数分发

**S3**类型的对象实现函数分发在R语言中是最常见的，我们在之前的文章中也经常提到。构建一个S3类型的分发函数非常简单，我们只需在函数体内部使用{{< hl-text primary >}}UseMethod(generic, object){{< /hl-text >}}的形式，指明分发函数的名称，以及需要按照那个参数（只能有一个）的数据类型进行分发。构建方法时，需要注意方法的参数列表必须与分发函数一致；而且方法的函数名必须是**分发函数.数据类型**或者**分发函数.default**的形式，后者表示当找不到与**object**的数据类型相对应的方法时，需要调用的函数。

假设**x**的**class**属性为**classA**，当我们调用S3分发函数**f**时，其中的**UseMethod**函数会查找**f.classA**是否存在，如果存在就调用**f.classA**函数，并设定其接收的参数以及所处的系统环境（**sys.frame**等）与分发函数**f**一致，如果不存在就调用**f.default**函数，若**f.default**函数也不存在就会抛出错误。

假设**x**的**class**属性中有多个值（**classA, classB, ...**），则**UseMethod**函数会按照这些属性值的先后顺序依次查找相应的方法，相当于S3方法继承（**classA**继承了**classB**的方法，...）。此时我们可以在S3方法中调用{{< hl-text primary >}}NextMethod{{< /hl-text >}}调用继承的方法（ *父方法* ），这种方式特别适合在 *子方法* 中处理数据差异，在 *父方法* 中实现共同的功能。

注意R语言中某些基础类型（数值、字符串等）的数据对象，在底层定义中就拥有**class**，它们的数据属性（**attributes**）中可能没有这一属性，但依然可以使用{{< hl-text primary >}}class{{< /hl-text >}}函数获取。大部分数组（假设为**x**）的class都是`mode(x)`，而整形和浮点型数组的class分别是`c("integer", "numeric")`、`c("double", "numeric")`，矩阵、高纬数组、的class分别是"matrix"、"array"，以及构成它们的数组的class。其它数据类型的class则可以直接由它们的**class属性**决定。

```R
# *S3类型的对象实现函数分发
> f <- function(x, y) UseMethod("f", x)
> f.character <- function(x, y) paste(x, y)
> f.default <- function(x, y) c(x, y)
> f("abc", "def")
[1] "abc def"
> f(123, 456)
[1] 123 456

# S3方法继承，f.classA不存在，f.character会被调用
> x <- structure("abc", class = c("classA", "character"))
> class(x)
[1] "classA"    "character"
# 注意S3分发函数只能按照一个参数（x）的数据类型进行分发
> f(x, 123)
[1] "abc 123"

# 调用S3方法继承的函数
> f.classA <- function(x, y) {
+   print("f.classA方法执行")
+   NextMethod("f", x)
+ }
> f(x, 123)
[1] "f.classA方法执行"
[1] "abc 123"
```

S3方法与普通的函数没有任何差异，所以有时为了提高代码的执行效率，我们也可以直接调用S3方法。但此时我们必须保证传给S3方法的参数是合适的，否则就可能造成歧义或触发异常。所以我们可以看到许多系统S3方法中，都会先使用{{< hl-text primary >}}inherits{{< /hl-text >}}等函数，检查参数的数据类型是否符合该方法的设定。

```R
# 直接调用方法可能会引起歧义
> f.character(123, 456)
[1] "123 456"
```

**.**在方法中被用于分割分发函数与数据类型，同时**.**也可以用在函数名中（如**as.numeric**），或class属性中（如**data.frame**），此时就有可能造成混淆，特别是**as**家族的函数。我们除了可以使用{{< hl-text primary >}}isGeneric、isS3method{{< /hl-text >}}等函数判断某个函数是否为分发函数，或者方法，还可以使用{{< hl-text primary >}}methods(generic, class){{< /hl-text >}}的形式，查找特定分发函数的方法，或者查找适用于某种数据类型的方法。如果我们已经知道了分发函数及方法的名称，还可以使用{{< hl-text primary >}}methods(generic, class){{< /hl-text >}}的形式，直接查找方法对应的函数。

```R
判断"as.numeric"是否为分发函数
> isGeneric("as.numeric")
[1] FALSE

# 查找分发函数"f"的方法
> methods("f")
[1] f.character f.default  

# 查找"f.character"对应的函数
> getS3method("f", "character")
function(x, y) paste(x, y)
```

## 2、S4函数分发

```R

```

new
setClass
setGeneric
setMethod
selectMethod
method_from_call

```R
setGeneric("f", function(x, y)x)
setMethod("f", signature(x="character", y="character"), function(x, y)"character")
f("abc", "def")

setMethod("Ops", signature(e1 = "character"), function(e1, e2) paste0(e1, e2))
Ops("abc", "def")
```

## 3、RC函数分发

setRefClass()


## 4、系统函数分发

**InternalMethods、groupGeneric**帮助文档

<br>

## 下一篇

- 并发运算

- 文件资源管理
- 网络资源管理

- 程序包管理
- 外部函数调用

- 图形化管理

- 随机数与概率分布
- 经典模型
- 大数据模型

{{< note "思考思考" "#e6e6ff" >}}
- S3对象`structure("abc", class = c("myClass"))`与`structure("abc", class = c("myClass", "character"))`有什么区别？

{{< /note >}}

<br>
