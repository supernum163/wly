---
title: "R语言编程篇——函数分发"
date: 2019-08-01
categories:
  - R语言
  - 编程
tags:
  - R语言编程
  - R语言数据类型
keywords:
  - R语言
  - 函数分发
thumbnailImagePosition: left
thumbnailImage: https://i.postimg.cc/KYSrkmvQ/image.png
---

不同类型的数据需要不同的处理方式，我们要实现某一类效果，往往需要根据特定类型的数据编写相应的函数，但我们可能希望像使用同一个函数一样使用这些函数（因为它们实现的效果是类似的），此时就需要用到**函数分发**机制。这篇文集我们将介绍R语言中函数分发的规则。

<!--more-->

<!-- toc -->

在R语言的函数分发体系中，负责根据数据类型将参数分配给特定函数的是**分发函数**(**generic-function**)，而负责实现某一项具体功能的是**方法**（**method**）。


## 1、S3类型的函数分发

**S3**类型的对象实现函数分发在R语言中是最常见的，我们在之前的文章中也经常提到。构建一个S3类型的分发函数非常简单，我们只需在函数体内部使用{{< hl-text primary >}}UseMethod(generic, object){{< /hl-text >}}的形式，指明分发函数的名称，以及需要按照那个参数（只能有一个）的数据类型进行分发。构建方法时，需要注意方法的参数列表必须与分发函数一致；而且方法的函数名必须是**分发函数.数据类型**或者**分发函数.default**的形式，后者表示当找不到与**object**的数据类型相对应的方法时，需要调用的函数。

假设**x**的**class**属性为**classA**，当我们调用S3分发函数**f**时，其中的**UseMethod**函数会查找**f.classA**是否存在，如果存在就调用**f.classA**函数，并设定其接收的参数以及所处的系统环境（**sys.frame**等）与分发函数**f**一致，如果不存在就调用**f.default**函数，若**f.default**函数也不存在就会抛出错误。

假设**x**的**class**属性中有多个值（**classA, classB, ...**），则**UseMethod**函数会按照这些属性值的先后顺序依次查找相应的方法，相当于S3方法继承（**classA**继承了**classB**的方法，...）。此时我们可以在S3方法中调用{{< hl-text primary >}}NextMethod{{< /hl-text >}}调用继承的方法（ *父方法* ），这种方式特别适合在 *子方法* 中处理数据差异，在 *父方法* 中实现共同的功能。

注意R语言中某些基础类型（数值、字符串等）的数据对象，在底层定义中就拥有**class**（决定S3方法继承），它们的数据属性（**attributes**）中可能没有这一属性（**class属性**），但依然可以使用**class函数**获取。然而**class函数**函数返回的可能并不是数据全部的**class**，大部分数组（假设为**x**）的**class**都是`mode(x)`，而整形和浮点型数组的**class**分别是`c("integer", "numeric")`、`c("double", "numeric")`，矩阵、高纬数组、的**class**分别是`"matrix"`、`"array"`，以及构成它们的数组的**class**。其它数据类型的**class**则可以直接由它们的**class属性**决定。

```R
# *S3类型的对象实现函数分发
> f <- function(x, y) UseMethod("f", x)
> f.character <- function(x, y) paste(x, y)
> f.default <- function(x, y) c(x, y)
> f("abc", "def")
[1] "abc def"
> f(123, 456)
[1] 123 456

# S3方法继承，f.classA不存在，f.character会被调用
> x <- structure("abc", class = c("classA", "character"))
> class(x)
[1] "classA"    "character"
# 注意S3分发函数只能按照一个参数（x）的数据类型进行分发
> f(x, 123)
[1] "abc 123"

# 调用S3方法继承的函数
> f.classA <- function(x, y) {
+   print("f.classA方法执行")
+   NextMethod("f", x)
+ }
> f(x, 123)
[1] "f.classA方法执行"
[1] "abc 123"
```

S3方法与普通的函数没有任何差异，所以有时为了提高代码的执行效率，我们也可以直接调用S3方法。但此时我们必须保证传给S3方法的参数是合适的，否则就可能造成歧义或触发异常。所以我们可以看到许多系统S3方法中，都会先使用{{< hl-text primary >}}inherits{{< /hl-text >}}等函数，检查参数的数据类型是否符合该方法的设定。

```R
# 直接调用方法可能会引起歧义
> f.character(123, 456)
[1] "123 456"
```

**.**在方法中被用于分割分发函数与数据类型，同时**.**也可以用在函数名中（如**as.numeric**），或class属性中（如**data.frame**），此时就有可能造成混淆，特别是**as**家族的函数。为了避免这些混淆，我们可以使用{{< hl-text primary >}}isGeneric、isS3method{{< /hl-text >}}等函数判断某个函数是否为分发函数，或者方法。我们还可以使用{{< hl-text primary >}}methods(generic, class){{< /hl-text >}}的形式，查找特定分发函数的方法，或者查找适用于某种数据类型的方法。

如果我们已经知道了分发函数及方法的名称，还可以使用{{< hl-text primary >}}methods(generic, class){{< /hl-text >}}的形式，直接查找方法对应的函数。

```R
判断"as.numeric"是否为分发函数
> isGeneric("as.numeric")
[1] FALSE

# 查找分发函数"f"的方法
> methods("f")
[1] f.character f.default  

# 查找"f.character"对应的函数
> getS3method("f", "character")
function(x, y) paste(x, y)
```

<br>

## 2、S4类型的函数分发

S3类型的函数分发每次只能验证一个参数的数据类型，为了严格的限制参数的数据类型，R语言的**methods**程序包中定义了S4函数分发系统。本质上S4对象可以被看作是一类特殊的S3对象，只不过S4对象对于成员变量的数据类型要求更加严格。以S3对象的角度来看，S4对象中的内容全部存储在数据属性（**attributes**）当中，但我们直接以操作数据属性的方式操作S4对象很容易打破S4对象的规则。

要生成一个S4类型的数据，我们可以首先使用{{< hl-text primary >}}setClass(class, slots, contains, ....){{< /hl-text >}}的形式定义一类S4对象，其中**class**为S4对象的类名，**slots**为成员变量及其数据类型，**contains**为需要继承的S4对象。接下来我们可以使用{{< hl-text primary >}}new(class, ....){{< /hl-text >}}的形式，生成该类S4对象的实例。为了方便这一过程，我们也可以使用**setClass**生成一个函数，专门用于生成相应类别的S4对象。获取S4对象成员变量的方式与S3对象不同，我们不能使用中括号或美元符，必须使用**@**符号。

```R
# 定义一类S4对象，并生成该类S4对象的实例
> setClass("label_2D", slots = c(label = "character", x = "numeric", y = "numeric"))
> myLabel2D <- new("label_2D", label = "坐标标签", x = 0, y = 0); str(myLabel2D)
Formal class 'label_2D' [package ".GlobalEnv"] with 3 slots
  ..@ label: chr "坐标标签"
  ..@ x    : num 0
  ..@ y    : num 0

# S4对象的继承
> lable_3D <- setClass("label_3D", slots = list(z = "numeric"), contains = "label_2D")
> myLabel3D <- lable_3D(myLabel, z = 0)

# 取S4对象中成员变量的值
> myLabel3D@label
[1] "坐标标签"
```

定义S4分发函数及相应的S4方法的过程与S3非常类似。首先我们需要使用{{< hl-text primary >}}setGeneric(name, def, ...){{< /hl-text >}}的形式定义一个S4分发函数，其中**name**即分发函数的名称；**def**即分发函数收到参数时应该如何处理，一般情况下我们需要直接使用{{< hl-text primary >}}standardGeneric{{< /hl-text >}}函数进行函数分发，当然我们也可以在这里处理接收到的参数或者方法的返回值。

首先我们需要使用{{< hl-text primary >}}setMethod(f, signature, definition, ...){{< /hl-text >}}的形式定义S4方法，其中**f**即我们之前定义的S4分发函数；**signature**中我们需要指明每个参数的数据类型；**definition**即方法的集体实现，注意其参数列表必须与分发函数中的**def**一致。

S4分发函数被调用时，会严格根据所有参数（不定长参数列表**...**除外）的数据类型分配S4方法，如果找不到相应的方法则会报错，没有默认方法。

```R
# 定义一个S4分发函数
> setGeneric("printLable", def = function(lab) standardGeneric("printLable"))
[1] "printLable"

# 定义一个S4方法
> setMethod("printLable", signature = "label_2D", 
+           definition = function(lab){
+             sprintf("(%d, %d) @ %s", lab@x, lab@y, lab@label)
+           })

# 调用S4分发函数
> printLable(myLabel2D)
[1] "(0, 0) @ 坐标标签"
```

setGroupGeneric
getMethod、selectMethod
method_from_call


<br>

## 3、RC函数分发

```R

```

setRefClass()


## 4、系统函数分发

**InternalMethods、groupGeneric**帮助文档

<br>

## 下一篇

- 并发运算

- 文件资源管理
- 网络资源管理

- 程序包管理
- 外部函数调用

- 图形化管理

- 随机数与概率分布
- 经典模型
- 大数据模型

{{< note "思考思考" "#e6e6ff" >}}
- S3对象`structure("abc", class = c("myClass"))`与`structure("abc", class = c("myClass", "character"))`有什么区别？
- S4方法可以直接调用吗？

{{< /note >}}

<br>
