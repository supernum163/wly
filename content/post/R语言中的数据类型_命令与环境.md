---
title: "面向语言的编程——R语言中的命令与执行环境"
date: 2019-06-10
categories:
  - R语言
  - 数据类型
tags:
  - R语言数据类型
  - R语言面向语言编程
keywords:
  - R语言
  - 数据类型
  - 面向语言编程
thumbnailImagePosition: left
thumbnailImage: https://i.postimg.cc/MH2TfzTg/image.png
---

**面向语言的编程**有时也被称作**元编程**，指的是一种计算机语言以另一种计算机语言（或自身）为**目标语言**，通过处理、执行目标语言来完成某项任务的过程。作为脚本语言的一种，**R语言**也拥有强大且便捷的元编程能力。这篇文章将介绍R语言中元编程的基础——命令与执行环境。

<!--more-->

<!-- toc -->

## 1、列表

R语言中的列表可以分为普通列表（**list**）和**单向链表型列表**（**pairlist**），两者之间可以互相转化。因为普通列表与**数组类数据**的存储结构更加类似，所以我们平时处理数据时用到的往往是普通列表。而单向链表型列表往往被用于辅助生成其它类型的对象，比如R语言中每个对象的**attributes**属性都是一个单向链表型列表。

在底层数据存储结构中，单向链表型列表由三部分组成，其中**carval**中存储的是当前值，或者说是列表的第一个值。**tagval**中存储的是一个变量名，即当前值的名称。**cdrval**中存储的则是链表的下一个节点。

而普通列表实际上每个元素都可以看作是一个数组或一个子别表，普通列表的名称存储在对象的**names**属性中的。注意使用{{< hl-text primary >}}list{{< /hl-text >}}函数生成列表时，列表中元素的取值需要当即计算，如果我们将某段R语言代码赋值给列表中的元素，则可以使用{{< hl-text primary >}}alist{{< /hl-text >}}函数。

```R
> pairlist(a = 1:10)      # 单向链表型列表
$a
 [1]  1  2  3  4  5  6  7  8  9 10
> list(a = 1:10)          # 普通列表
$a
 [1]  1  2  3  4  5  6  7  8  9 10
> alist(a = b + 1:10)     # 变量b尚未定义
$a
b + 1:10
```

<br>

## 2、执行环境

**执行环境**是R语言中查找变量取值、函数的位置。R语言中的执行环境存在 *继承* 关系，即子执行环境中不存在的变量、函数可以从父执行环境中寻找，反之则不能。子执行环境只能继承一个父执行环境，但是父执行环境继承的内容也可以被子执行环境继承。

每当我们载入一个**程序包**就会生成一个与程序包相对应的执行环境，该程序包可以继承上一个载入的程序包的执行环境。比较特别的是：{{< hl-text primary >}}globalenv(){{< /hl-text >}}即**全局执行环境**，是当前工作的执行环境，总是处于所有已载入程序包的最后一层，所以可以继承所有已载入程序包的函数和数据。{{< hl-text primary >}}baseenv(){{< /hl-text >}}是R系统载入的第一个程序包，它父执行环境是{{< hl-text primary >}}emptyenv(){{< /hl-text >}}，后者是唯一没有父执行环境的执行环境。{{< hl-text primary >}}.BaseNamespaceEnv{{< /hl-text >}}是**base**程序包的**namespace**，实际上每当我们载入一个程序包都会生成两个执行环境**namespace:packageName**和**package:packageName**,后者拥有的元素只是前者的一部分，一般情况下只有后者可以被载入。由于**base**程序包的特殊性，所以两个执行环境都会被载入，两者唯一的区别在于：**namespace:base**的父执行环境是全局执行环境。

执行环境由三部分组成，其中：**frame**是一个由变量名和取值构成的单向链表型列表；**enclos**即当前执行环境的上层执行环境（父执行环境）；**hashtab**是一个**list**形的哈希缓存表，相当于对**frame**的缓存，当其中的某个值被删除时，占用的空间不会被清除，其底层C语言代码中的**length**变量表示正在使用的列表元素个数，**truelength**变量表示真正分配的列表长度。注意执行环境中的变量、函数等内容只能存储在**frame**或**hashtab**二者之一。

执行环境可以与列表互相转化，同时我们也可以像列表一样操作执行环境中的元素。

```R
> x <- as.environment(list(a = 1, b = 2)); x      # 将列表转化为执行环境
<environment: 0x8b261e8>
> c(x$a, x$b)                                     # 取出执行环境中的元素
[1] 1 2
> parent.env(x)                                   # 获取执行环境的父执行环境
<environment: R_EmptyEnv>
> pos.to.env(1)                                   # 根据位置获取执行环境，全局执行环境的位置为1，每上一层位置加1
<environment: R_GlobalEnv>
```

<br>

## 3、变量名

R语言中的**变量名**是一类被称为**symbol**（或者**name**）的对象，变量名本质上是一个字符串，但与字符串不同的是，变量名可以对应一个特定的值。比较特别的是，函数名或者操作符也是变量名的一种，它们的取值是一个特定的函数。对于系统函数名（参考**.Internal**、**.Primitive**帮助文档）而言，其对应的函数存储在变量名对象本身。

我们可以使用{{< hl-text primary >}}as.symbol、as.name{{< /hl-text >}}函数，将一个字符串转化为一个变量名，并使用{{< hl-text primary >}}eval{{< /hl-text >}}函数取出该变量名所对应的值。

```R
> a <- 123; x <- as.symbol("a")
> x           # 注意x的取值是一个变量名
a
> eval(x)     # 将x的取值作为变量名执行
[1] 123
```

<br>

## 4、命令

**命令**是由字面值、变量名、及子命令构成的指令集，命令可以被解析为**指令树**，指令树的最顶层是需要最后被执行的指令，而最底层是需要最先被执行的指令。比如`sum(a, 1)`被解析之后，函数**sum**在最顶层，变量名**a**及字面值**1**在最底层，所以命令执行时会先寻找**a**的取值，再将该值与**1**一同作为参数传给**sum**执行。

在R语言中命令也可以等同于**call**（或者**function call**），因为操作符实际上也是函数，所以任何命令都可以看作是函数的调用或者嵌套调用。

而另一个概念**language**的定义容易让人产生混淆，如果一个对象的存储类型（**typeof**）为**language**，这个对象一定是命令；如果我们使用{{< hl-text primary >}}is.language{{< /hl-text >}}判断一个对象是否为**language**，则变量名、命令、命令集都可以被称为**language**。简而言之，R语言的底层代码（**C语言**）中，**language**等同于命令；而R语言中将**language**归类为了任何可被执行的 *R语言代码* 。

最后，概念**formula**指的是含有英文波浪号**～**的命令，常被用于表示数学模型。比如在线性回归模型中，**～**之前的变量名会被视为因变量，而**～**之后的命令会被视为对自变量的线性变换。

在R语言命令行中直接输入命令，则命令会被立即执行，所以我们需要使用{{< hl-text primary >}}substitute、quote{{< /hl-text >}}等函数捕获未执行的命令，或者使用{{< hl-text primary >}}call{{< /hl-text >}}函数生成一个命令。同样命令也可以使用**eval**函数执行。

```R
> quote(a + 1)          # 直接捕获命令
a + 1
> call("sum", 1, 2)     # 生成 function call
sum(1, 2)
> y ~ a + b             # 生成 formula
y ~ a + b
```

<br>

## 5、命令集

**命令集**（**expression**）是一系列命令的集合，处于同一个命令集中的命令会按照先后顺序执行，所以命令集中的命令可以引用上一个命令的变量或运算结果。我们也可以使用大括号操作符**{}**达到同样的效果，但**{}**生成的是嵌套命令而非命令集。

```R
> y <- expression(x <- 1, x + 2); y     # 生成命令集
expression(x <- 1, x + 2)
> eval(y)
[1] 3
> z <- quote({x <- 1; x + 2})           # 生成嵌套命令
> c(typeof(y), typeof(z))
[1] "expression" "language"  
```

<br>

## 6、延时命令

R语言中有一类特殊的对象——**promise**，这里我们姑且称之为**延时命令**。延时命令实际上包含了一段R语言代码与一个执行环境，延时命令一旦被 *需要* ，其中的代码部分就会在其执行环境中被执行，执行完毕后其执行环境会被删除，从而转化为其它类型的对象。

如下函数中，如果我们使用{{< hl-text primary >}}assign{{< /hl-text >}}函数直接将命令`a + 1`赋值给**x**则会报错，因为变量**a**尚不存在；如果使用{{< hl-text primary >}}delayedAssign{{< /hl-text >}}函数，则相当于给**x**赋值了一个延时命令，延时命令的默认执行环境是当前工作环境。当我们需要用到变量**x**时，延时命令会被立即执行，所以我们需要在此之前给变量**a**赋值。

```R
> assign("x", a + 1)
Error in assign("x", a + 1) : 找不到对象'a'
> delayedAssign("x", a + 1)
> a <- 2; x
[1] 3
# 注意延时命令只会被执行一次
> delayedAssign("x", {cat("promise 被执行\n"); 1})
> x
promise 被执行
[1] 1
> x
[1] 1
```

<br>

## 7、函数

R语言中的函数可以分为普通函数（**closure**）和系统函数（**builtin、special**）等。普通函数总是由三部分构成：

- **formals**是函数的参数列表，参数的值是以**延时命令**的形式，与参数名一起存储在一个**单向链表型列表**中的，所以函数定义时参数可以是还未被定义的变量，但函数调用时必须定义相应的变量，或者指明参数的取值。

- 函数的**body**部分是一段由R语言代码构成的**函数体**，也可以为空。

- 函数的**environment**部分是函数定义时的执行环境，决定了函数被存储在什么位置。此外函数还有调用时的执行环境，决定了参数的寻找位置；最后函数内部的执行环境，保证了函数内执行的R语言代码不会作用到函数外的执行环境中，除非使用全局赋值命令。

```R
> c(typeof(.Primitive), typeof(.Internal), typeof(mean))
[1] "builtin" "special" "closure"
> f <- function(a = 0) a + 1      
> formals(f)                      # 取函数参数
$a
[1] 0
> body(f)                         # 取函数体
a + 1
> environment(f)                  # 取函数定义时的执行环境
<environment: R_GlobalEnv>
```

<br>

{{< note "思考思考" "#e6e6ff" >}}
- **普通列表**与**单向链表型列表**分别有什么优劣？
- R语言中为什么不将**变量名**与**取值**存储在一起？
- 函数的**内部执行环境**与函数**调用时的执行环境**有什么联系？

{{< /note >}}

<br>
