---
title: "R语言中的数值"
date: 2019-05-22
categories:
  - R语言
  - 数据类型
tags:
  - R语言数据类型
  - R语言数学运算
keywords:
  - R语言
  - 数据类型
thumbnailImagePosition: left
thumbnailImage: https://i.postimg.cc/fbdrXS6P/R.png
---

在之前的**R语言中的数学运算**系列文章中，我们已经分别总结了如何对**0维**、**1维**、**n维**数值进行数学运算。这篇文章我们着重于从数据结构上总结R语言中 *广义* 的数值型数据。

<!--more-->

<!-- toc -->

## 1、广义的数值

1. **浮点型数值**, R语言中绝大多数情况下我们接触到的数值，都是浮点型数据（**double**，即R语言中的**numeric**）。**double**类型的数值最大可以保留15-16位有效数字，但R语言中默认只显示前7位，超出部分总是以指数的形式表示。

2. **整型数值**，因为存在数据类型的自动转化机制，在R语言中整形数值与浮点型数值区分的并不太明显，有时候我们输入一个整数，而实际上R语言会默认以浮点型数据存储。所以真正输入整数的方法是：在数值后面加入R语言中的保留字符{{< hl-text primary >}}L{{< /hl-text >}}。

```R
> c(typeof(123), typeof(as.integer(123)), typeof(123L))
[1] "double"  "integer" "integer"
```

3. **复数型数值**，R语言中的复数本质上是对C语言中复数标准库的包裹，复数可以看作由两个浮点型数值分别表示的**实部**和**虚部**，在R语言中生成复数的方式很简单，只需在数值后面加入R语言中的保留字符{{< hl-text primary >}}i{{< /hl-text >}}。

4. **逻辑值**，R语言中虽然有单独的数据类型用于表示逻辑值，但实际上逻辑值依然是以整形数据存储的，所以R语言中的逻辑值与数值可以直接转换。注意逻辑值转数值时**TRUE**为**1**、**FALSE**为**0**，而数值转逻辑值时只有数值**0**为**FALSE**，*一切非零皆为真*。

5. 除了以上数据类型外，在R语言中还有一些其它类型的数据，本质上也是以数值的形式存储的。比如日期时间类型的数据，本质上是一个浮点型数据；因子形数据，本质上是一个整形数组与一个由字符串数组组成的**levels**属性。

<br>

## 2、进制转换

在R语言中，我们可以分别使用{{< hl-text primary >}}as.octmode、as.hexmode、as.integer{{< /hl-text >}}函数，将数值在**八进制**、**十六进制**与**十进制**之间进行转换。注意这里进制之间的转换只是class属性的转换，实际上依然是以整数的形式存储数据。

有时候我们需要将字符串转换为数值，特别是当字符串中包含非十进制数值时（比如将二进制**"11010"**或十六进制**"1a"**转化为数值**26**），则可以使用命令{{< hl-text primary >}}strtoi(x, base = 0L){{< /hl-text >}}，其中**base**的值即字符串中数值的进制。

```R
> strtoi(c("0xff", "077", "123"))
[1] 255  63 123
> strtoi(c("ffff", "FFFF"), 16L)
[1] 65535 65535
> strtoi(c("177", "377"), 8L)
[1] 127 255
```

## 3、二进制数组与比特位运算

有时我们需要生成二进制（**byte**）类型的数组，虽然我们可以通过{{< hl-text primary >}}0x{{< /hl-text >}}前缀，输入十六进制数字，但这种方式输入的内容会被转换为整数而非二进制。真正的做法应该是使用{{< hl-text primary >}}as.raw{{< /hl-text >}}函数，注意**as.raw**只能转化取值范围在0-255的整数。

如果我们想要取出整数或二进制数组中每一个比特位对应的值（0或1），则可以分别使用{{< hl-text primary >}}intToBits、rawToBits{{< /hl-text >}}函数。但遗憾的是R语言中并没有专用于存储比特位的对象，所以每个比特位所对应的值都会被存储在一个**byte**中，最终生成的二进制数组的顺序恰好与比特位的顺序相反。与这个过程相反，我们可以使用命令{{< hl-text primary >}}packBits(x, type = c("raw", "integer")){{< /hl-text >}}将由比特位构成的二进制数组（**Bits**）转换为整数或二进制数组。

```R
> intToBits(26)
 [1] 00 01 00 01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
> rawToBits(as.raw(26))
[1] 00 01 00 01 01 00 00 00
> packBits(intToBits(26))
[1] 1a 00 00 00
```

对整数型或二进制型数值，我们可以分别使用{{< hl-text primary >}}bitwAnd、bitwOr、bitwXor、bitwNot、bitwShiftL、bitwShiftR{{< /hl-text >}}函数，按比特位进行求且、或、非、异或、左移、右移。

```R
> c(bitwNot(15L), bitwAnd(15L, 7L), bitwOr (15L, 7L), bitwXor(15L, 7L))
[1] -16   7  15   8
> c(bitwShiftL(2L, 1L), bitwShiftR(2L, 1L))
[1] 4 1
```

<br>

{{< note "思考思考" "#e6e6ff" >}}
- R语言中支持单精度（**float**）类型的数值吗（参考`is.single`的帮助文档）？
- 如何在R语言中实现**itoa**（将数值转化为n进制字符串）？
- 如何在R语言中以二进制（0或1）的形式输出二进制数组？
{{< /note >}}

<br>
