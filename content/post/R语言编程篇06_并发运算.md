---
title: R语言编程篇_并发运算
date: 2019-08-16
categories:
  - R语言
  - 编程
tags:
  - R语言编程
keywords:
  - R语言
  - 并发运算
  - apply
thumbnailImagePosition: left
thumbnailImage: https://s2.ax1x.com/2019/08/04/eytzEn.png
---

**并发运算**指的是使用相同的运算方式（**函数**），同时作用于多个结构（**数据类型**）类似的数据。，并发运算的运算结果互不影响，运算可以同时进行，因此可以极大的节省运算时间。这篇文集我们将介绍R语言中的并发运算。

<!--more-->

<!-- toc -->

我们在之前的文章中已经介绍过，R语言中数据结构是以**数组**为基础建立的，没有以单个值的形式存在的对象——**标量值**(**scalars**)，

## 1、对数组进行并发运算

apply(X, MARGIN, FUN, ...)
aggregate(x, ...)
sweep(x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...)

## 2、对列表进行并发运算

lapply(X, FUN, ...)

sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)

vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)

replicate(n, expr, simplify = "array")

simplify2array(x, higher = TRUE)


## 3、Apply a Function to Multiple List or Vector Arguments

mapply is a multivariate version of sapply. mapply applies FUN to the first elements of each ... argument, the second elements, the third elements, and so on. Arguments are recycled if necessary

mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE,
       USE.NAMES = TRUE)



## 4、Recursively Apply a Function to a List


rapply is a recursive version of lapply with flexibility in how the result is structured (how = "..")

rapply(object, f, classes = "ANY", deflt = NULL,
       how = c("unlist", "replace", "list"), ...)


## 5、Apply a Function Over Values in an Environment

eapply applies FUN to the named values from an environment and returns the results as a list. The user can request that all named objects are used (normally names that begin with a dot are not). The output is not sorted and no enclosing environments are searched.

eapply(env, FUN, ..., all.names = FALSE, USE.NAMES = TRUE)


## 6、Common Higher-Order Functions in Functional Programming Languages

Reduce uses a binary function to successively combine the elements of a given vector and a possibly given initial value. Filter extracts the elements of a vector for which a predicate (logical) function gives true. Find and Position give the first or last such element and its position in the vector, respectively. Map applies a function to the corresponding elements of given vectors. Negate creates the negation of a given function.

Reduce(f, x, init, right = FALSE, accumulate = FALSE)
Filter(f, x)
Find(f, x, right = FALSE, nomatch = NULL)
Map(f, ...)
Negate(f)
Position(f, x, right = FALSE, nomatch = NA_integer_)



## parallel

mclapply(X, FUN, ...,
         mc.preschedule = TRUE, mc.set.seed = TRUE,
         mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),
         mc.cleanup = TRUE, mc.allow.recursive = TRUE, affinity.list = NULL)

mcmapply(FUN, ...,
         MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE,
         mc.preschedule = TRUE, mc.set.seed = TRUE,
         mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),
         mc.cleanup = TRUE, affinity.list = NULL)

mcMap(f, ...)

<br>

{{< note "思考思考" "#e6e6ff" >}}
- ？

{{< /note >}}

<br>
