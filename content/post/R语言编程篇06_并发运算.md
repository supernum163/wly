---
title: R语言编程篇——并发运算
date: 2019-08-12
categories:
  - R语言
  - 编程
tags:
  - R语言编程
keywords:
  - R语言
  - 并发运算
  - apply家族函数
thumbnailImagePosition: left
thumbnailImage: https://s2.ax1x.com/2019/08/04/eytzEn.png
---

**并发运算**指的是使用相同的运算方式（**函数**），同时作用于多个结构类似（**数据类型**相同）的数据。并发运算的运算结果互不影响，运算可以同时进行，因此可以极大的节省运算时间。这篇文章我们将介绍R语言中的并发运算。

<!--more-->

<!-- toc -->

有时候我们编写的函数需要作用于单个对象（列表中的单个元素、矩阵中的行列，...），然而**高维对象**（**Recursive Object**）往往包含多个这样的元素，将函数作用于高维对象时，我们可以使用循环流程，当然我们也可以使用更加高效、便捷的方式——并发运算。

将高纬对象中的每个元素都取出来，用相同的函数同时对它们进行运算，最后根据元素原来的先后次序，用运算结果生成新的高纬对象，这就是我们要介绍的并发运算的理念。R语言中实现这类理念的函数有很多，它们在底层代码中仍是以循环的方式实现的，并不能算是真正意义上的并发运算（ *伪并发运算* ？），但是相比直接在R语言中使用循环体则要高效很多。

<br>

## 1、对单维数组进行并发运算

我们在之前的文章中已经介绍过，R语言中没有以单个值（数值或字符串）的形式存在的对象——**标量值**(**scalars**)，所有数看起来像是标量值的对象实际上都可以被当作**单维数组**（**Atomic Vector**）处理。大多数原则上只能作用于标量值的函数，在R语言中同样也能作用于数组（比如加法运算——`+`,可以将两个数组相应位置上的元素依次相加）。因此对于单维数组，绝大多数情况下都没有必要使用并发运算。

但是有时候我们希望让某个**命令**（**expr**）运行指定次数，则可以使用{{< hl-text primary >}}replicate{{< /hl-text >}}函数。或者对于某些只能接受单个值作为参数的函数，我们则可以使用{{< hl-text primary >}}sapply{{< /hl-text >}}函数，将数组中的每个元素分别传递给该函数进行运算。

```R
# 使用replicate，运行5次rexp(2)
> replicate(5, rexp(2))
         [,1]      [,2]      [,3]       [,4]      [,5]
[1,] 2.039849 1.9329975 1.5113277 0.01557205 0.6002478
[2,] 1.372845 0.6682618 0.8708184 0.62270078 0.1020941

# 使用sapply，将数组c(3, 9)中的元素分别传递给seq
> sapply(c(3, 9), seq)
[[1]]
[1] 1 2 3

[[2]]
[1] 1 2 3 4 5 6 7 8 9

```

## 2、对多纬数组进行并发运算

对于矩阵或高纬数组，并发运算的意义就显得非常重要了（比如我们可能需要对矩阵进行行列汇总），此时我们可以使用{{< hl-text primary >}}apply{{< /hl-text >}}函数：

`apply(X, MARGIN, FUN, ...)`

- **X**即需要被处理的矩阵或高纬数组
- **MARGIN**即需要按照哪一个纬度进行处理，对于矩阵而言，第一个纬度是列、第二个纬度是行，指定**MARGIN**为1表示列纬度不会被压缩，也就是按行汇总
- **FUN**即需要进行运算的函数，高维对象**X**中**MARGIN**纬度上的每一个元素都会作为第一个参数传递给**FUN**
- **...**即需要传递给函数**FUN**的其余参数

```R
# 按列汇总数据集mtcars，求每一列的中位数及上下四分位数
> apply(mtcars, 2, quantile, c(.25, .5, .75))
       mpg cyl    disp    hp  drat      wt    qsec vs am gear carb
25% 15.425   4 120.825  96.5 3.080 2.58125 16.8925  0  0    3    2
50% 19.200   6 196.300 123.0 3.695 3.32500 17.7100  0  0    4    2
75% 22.800   8 326.000 180.0 3.920 3.61000 18.9000  1  1    4    4
```

除了**apply**函数外，还有许多函数也可以对矩阵或高纬数组进行类似并发运算的操作，它们大多是为了便于数学运算设计的。比如{{< hl-text primary >}}aggregate{{< /hl-text >}}函数，可以对矩阵进行分组汇总；{{< hl-text primary >}}sweep{{< /hl-text >}}函数，可以将高维数组某个纬度上的每一个元素，分别与其**STATS**参数对应的数据，进行相应的数学运算。

<br>

## 3、对列表（或数组）进行并发运算

类似对数组进行并发运算，我们可以分别使用{{< hl-text primary >}}lapply{{< /hl-text >}}函数对列表进行并发运算，此时我们就不需要指定**MARGIN**，因为**lapply**函数会将列表中的每个元素都作为第一个参数传递给**FUN**。

有时候对列表进行并发运算时，**FUN**总是会生成数据类型、数据长度相同运算的结果，此时如果运用**lapply**函数，并发运算的结果总是列表，如果我们希望将原先的列表看作第一个纬度，并将**FUN**的运算结果看作是其余纬度，从而将最终并发运算的结果装入数组类型的数据中，则可以使用{{< hl-text primary >}}sapply{{< /hl-text >}}函数。

类似**sapply**函数，我们可以使用更加稳定、高效的{{< hl-text primary >}}vapply{{< /hl-text >}}函数，通过**FUN.VALUE**参数指定**FUN**的返回值类型、长度，此时也可以生成数组类型的并发运算结果。

`lapply(X, FUN, ...)`
`sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)`
`vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)`

- **simplify**即并发运算的结果，在数据结构方面是否需要被简化。取值也可以为字符串`c("vector", "matrix", "array")`，表示需要被简化为特定类型的对象
- **FUN.VALUE**即**FUN**的返回值类型、长度
- **USE.NAMES**即是否自动为并发运算的结果关联**names**属性

```R
> X <- list(a = seq(3), b = seq(9))

# 使用lapply，并发运算的结果仍是列表类型的数据
> lapply(X, range)
$a
[1] 1 3

$b
[1] 1 9

# 使用sapply，并发运算的结果是数组类型的数据
> sapply(X, range)
     a b
[1,] 1 1
[2,] 3 9

# 使用vapply，并发运算的结果是数组类型的数据
> vapply(X, range, c(最小值 = 0, 最大值 = 0))
       a b
最小值 1 1
最大值 3 9
```

<br>

## 4、对执行环境进行并发运算

类似使用**lapply**函数对列表进行并发运算，我们也可以对执行环境进行并发运算，此时我们需要用到{{< hl-text primary >}}eapply{{< /hl-text >}}函数：

`eapply(env, FUN, ..., all.names = FALSE, USE.NAMES = TRUE)`

- **env**即需要被处理的执行环境
- **all.names**表示是否使用执行环境中所有的变量，默认情况下不使用**隐藏变量**——以英文句点**.**开头的变量。

```R
> e <- as.environment(X)

#使用eapply，求执行环境e中各对象的五分位数
> eapply(e, fivenum)
$b
[1] 1 3 5 7 9

$a
[1] 1.0 1.5 2.0 2.5 3.0

```

<br>

## 5、对列表进行递归式的并发运算

有时列表中包含的元素数据类型各不相同，或者列表中包含子列表。如果我们希望便利列表的每一个元素，遇到子列表则进行递归（遍历子列表的每一个元素），并且只对其中特定数据类型的 *数据节点* 进行运算，则可以使用{{< hl-text primary >}}rapply{{< /hl-text >}}函数：

`rapply(X, FUN, classes = "ANY", deflt = NULL, how = c("unlist", "replace", "list"), ...)`

- **classes**即**X**中那些数据类型的元素需要被运算，取值为**ANY**时表示任意类型的数据
- **deflt**即没有被运算的元素在并发运算结果中对应的默认值，当**how**参数取值为**replace**时，此参数无效
- **how**即如何决定并发运算结果的数据结构，取值为**list**表示保留原有的列表结构，**unlist**表示使用数组结构，**replace**表示用运算结果替代原有的元素，未被运算的元素不变

```R
> X <- list(list(a = pi, b = list(c = 1L)), d = "a test")

# 使用rapply对列表进行递归式的并发运算
> rapply(X, sqrt, classes = c("numeric", "integer"), 
+        deflt = NA_real_, how = "unlist")
       a      b.c        d 
1.772454 1.000000       NA 
```

**rapply**函数对于树状结构的列表数据非常有效，类似的，在**聚类分析**中我们会经常用到树状图，要修改树状图中每一个节点的属性，我们可以使用{{< hl-text primary >}}dendrapply{{< /hl-text >}}函数。

<br>

## 6、使用多个可变参数进行并发运算

以上**apply**家族函数中，我们每次只能将**X**中的一个元素传递给**FUN**参数对应的函数，如果我们希望**FUN**每次都要接收多个取值可变的数据参数，那么就需要用到{{< hl-text primary >}}mapply{{< /hl-text >}}函数：

`mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)`

- **...**即**FUN**每次被调用时，需要接收的取值可变的参数，注意这里数组或列表中相应位置上的元素需要一一对应，作为**FUN**中参数的取值
- **MoreArgs**即**FUN**每次被调用时，需要接收的取值相同的参数

```R
# 使用mapply，相当于调用了2次rep函数
# rep(x = 4,  times = 3) 
# rep(x = 3,  times = 4) 
> mapply(rep, x = 4:3, times = 3:4)
[[1]]
[1] 4 4 4

[[2]]
[1] 3 3 3 3

```

<br>

除了上文介绍到的并发运算，R语言中还有许多其它的方式可以提高工作效率，比如使用**servr**程序包开启后台程序，使用**parallel**程序包实现集群运算，...

<br>

{{< note "思考思考" "#e6e6ff" >}}
- 对数据框使用**sapply**函数进行按列求均值，最终会生成那种数据类型的结果？
- **rapply**函数中的**classes**支持类继承关系吗？
- **Map**函数设计的意义是什么？

{{< /note >}}

<br>
