---
title: "使用R语言对矩阵进行数学运算"
date: 2019-04-28
math: true
categories:
  - R语言
  - 数学运算
tags:
  - R语言数学运算
keywords:
  - R语言
  - 数学运算
thumbnailImagePosition: left
thumbnailImage: https://s2.ax1x.com/2019/08/04/eyNM8K.png
---

**R语言**作为一门专为统计分析诞生的语言，数学运算自然是必不可少的。这篇文章将介绍R语言是如何对**矩阵**进行数学运算的。
<!--more-->

<!-- toc -->

<br>

# 1、什么是矩阵  

{{< image classes="fancybox nocaption fig-50" src="https://s2.ax1x.com/2019/08/04/eyNQgO.png" >}}

在R语言中，**Matrix**（矩阵）是一个由行列结构组成的数据对象。与 [数组](../../使用R语言对数组进行数学运算/#1-什么是数组 )不同的是，矩阵是二维数据对象，而数组是一维数据对象。所以我们可以结合使用矩阵的**行下标**、**列下标**，来筛选出矩阵中的特定元素。

在R语言中除了 [数字](../../使用R语言对数字进行数学运算)（0维）、 [数组](../../使用R语言对数组进行数学运算)（1维）、 [矩阵](#)（2维），还存在更高维度的数据对象——**Array**（高纬数组）。高纬数组在其每一个维度上都拥有相应的**维度下标**和取值，我们可以通过特定维度的下标获取相应的取值。

<br>

# 2、矩阵的生成与运用

## 2.1、生成矩阵

在R语言中我们可以使用{{< hl-text primary >}}matrix{{< /hl-text >}}函数生成矩阵:

`matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)`

- **data**即用于生成矩阵的数组，当数组的长度**n**小于$nrow * ncol$时，数组中的元素会被重复使用；反之，只有数组中的前$nrow * ncol$个元素会被使用
- **nrow、ncol**即矩阵的**行、列数目**，默认情况下会生成一个**n行1列**（**n*1**）的矩阵，相当于指定了`ncol = 1`
- **byrow**表示数组是否应该按行排列生成最终的矩阵，默认取值为**FALSE**，代表按列排列
- **dimnames**即矩阵的**维度名称**（行列名），可以为**NULL**，代表没有行列名（默认）；或是被**list**包裹的两个数组，分别代表行名、列名

```R
> matrix(1:6, nrow = 2, byrow = TRUE, dimnames = list(NULL, letters[1:3]))
     a b c
[1,] 1 2 3
[2,] 4 5 6
```

<br>

## 2.2、矩阵的维度与长度

我们可以分别使用{{< hl-text primary >}}nrow、ncol{{< /hl-text >}}函数，来获取矩阵的行数、列数。我们还可以使用{{< hl-text primary >}}dim{{< /hl-text >}}函数，获取数组在各个维度的长度（对于矩阵，其行、列分别对应其第一、第二个维度，所以矩阵的维度是一个长度为2的数组）。

对于一维数组，我们可以使用{{< hl-text primary >}}length{{< /hl-text >}}计算数组长度，同样的我们也可以对矩阵使用**length**函数，从而计算矩阵中包含多少个元素。

```R
> (x <- matrix(1:6, nrow = 2))
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
```

| nrow(x) | ncol(x) | dim(x)  | length(x) |
| :------ | :-------| :-------| :---------|
| 2       | 3       | c(2, 3) | 6         |

<br>

## 2.3、矩阵的维度名称

我们已经总结了如何在生成矩阵的时候，使用**dimnames**参数为矩阵指定维度名称。对于已经生成的矩阵，我们可以通过{{< hl-text primary >}}dimnames{{< /hl-text >}}函数来取得或设定维度名称，通过{{< hl-text primary >}}rownames、colnames{{< /hl-text >}}函数来取得或设定行名、列名。

```R
> dimnames(x) <- list(NULL, LETTERS[1:3]); x
     A B C
[1,] 1 3 5
[2,] 2 4 6
```

## 2.4、矩阵合并、取子集

对于两个矩阵（或一维数组），我们可以分别使用{{< hl-text primary >}}rbind、cbind{{< /hl-text >}}实现按行、按列合并。

我们已经总结了如何使用**[]**函数筛选数组中的特定元素，这个函数也可以适用于矩阵。我们可以在**[]**中传入两个数组并以逗号隔开，分别代表行、列的**筛选条件**，当筛选条件为空时则代表全选。其中：

- 当筛选条件为**数值类**的数组时，代表在特定维度筛选**维度下标**等于该数组的值
- 当筛选条件为**字符类**的数组时，代表在特定维度筛选**维度名称**等于该数组的值
- 当筛选条件为**逻辑值类**的数组时（此时数组需要与维度的长度相同，否则数组中的值会被重复利用），代表特定维度相应位置的值是否应该被保留。

注意当我们在某个维度筛选特定值时，筛选结果往往会比之前少一个维度。所以`x[1,]`会筛选出一个数组，而非矩阵。

此外，对于矩阵筛选，我们可以在**[]**中只传入一个数组，此时相当于将矩阵按照默认方式转化为数组然后在进行筛选。我们还可以传入一个与矩阵等规模（行列相同）的**逻辑矩阵**时，相当于筛选与逻辑矩阵中**TRUE**元素所在位置对应的元素。

```R
> x <- matrix(1:6, nrow = 2)
> rbind(x, x[1,])
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
[3,]    1    3    5
> cbind(x, 7:8)
     [,1] [,2] [,3] [,4]
[1,]    1    3    5    7
[2,]    2    4    6    8
```

## 2.5、矩阵的行列互换

在R语言中，我们可以使用{{< hl-text primary >}}t{{< /hl-text >}}函数对矩阵进行列互换。特别的，**t**函数也可以转置数组，转化后会生成一个$1 \times n$（1行n列）的矩阵。

```R
> t(matrix(1:6, nrow = 2))
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
> t(1:3)
     [,1] [,2] [,3]
[1,]    1    2    3
```

<br>

# 3、矩阵的基本数学运算

我们在 [上文](../../使用r语言对数组进行数学运算/#3-数组的基本数学运算)中总结了对数组进行数学运算时的规律，类似的规律对于矩阵也同样适用：如果两个行列数目相同的矩阵进行数学运算，相当于分别对矩阵中行列下标对应的元素进行数学运算，否则长度较短的矩阵中的元素会被重复利用。

<br>

# 4、矩阵特有的数学运算

## 4.1、取对角矩阵、上下三角矩阵

我们可以使用{{< hl-text primary >}}diag{{< /hl-text >}}函数来取矩阵的对角元素，或者生成一个**对角矩阵**。通过{{< hl-text primary >}}isSymmetric{{< /hl-text >}}函数，我们可以判断一个矩阵是否为对角矩阵。通过{{< hl-text primary >}}lower.tri、upper.tri{{< /hl-text >}}函数，我们可以生成一个由逻辑值组成的**上、下三角矩阵**，结合矩阵筛选的规则，我们就可以取出矩阵上、下三角区域的元素。

```R
> diag(matrix(1:9, nrow = 3))
[1] 1 5 9
> diag(1, nrow = 2, ncol = 4)
     [,1] [,2] [,3] [,4]
[1,]    1    0    0    0
[2,]    0    1    0    0
> upper.tri(matrix(1:6, nrow = 2))
      [,1]  [,2] [,3]
[1,] FALSE  TRUE TRUE
[2,] FALSE FALSE TRUE
```

<br>

## 4.2、矩阵相乘与内积、外积

我们可以通过运算符{{< hl-text primary >}}%*%{{< /hl-text >}}计算两个矩阵之间的乘积，注意向量的乘积与普通乘法的区别。假设**X、Y、Z**均为矩阵：

$$\begin{cases}
  Z[i,j] = X[i,] * Y[,j] &\text{if } (Z = X \enspace \%*\% \enspace Y) \\\\ 
  Z[i,j] = X[i,j] * Y[i,j] &\text{if } (Z = X * Y)
\end{cases}$$

矩阵的乘法运算必须要求**X**的列数与**Y**的行数相同。但实际运用中我们经常会遇到两个行列相同的矩阵，此时如果想计算乘积，则需要对其中一个矩阵进行 [行列互换](#-2-5-矩阵的行列互换)。当然我们也可以使用R语言中的两个快捷函数{{< hl-text primary >}}crossprod、 tcrossprod{{< /hl-text >}}，来以这种方式计算矩阵乘积。

$$\begin{cases}
  crossprod(X, Y) = X^TY \\\\ 
  tcrossprod(X, Y) = XY^T
\end{cases}$$

对于两个长度分别为**n、m**的数组数组**x、y**，我们可以使用操作符{{< hl-text primary >}}%x%,{{< /hl-text >}}或者函数{{< hl-text primary >}}kronecker{{< /hl-text >}}来计算它们之间的**内积**，最终生成的结果相当于分别用**x**中的每个元素与**y**相乘，再将n个长度为m的数组合并为一个长度为$n \times m$的数组。

此外我们还可以通过操作符{{< hl-text primary >}}%o%{{< /hl-text >}}或者函数{{< hl-text primary >}}outer{{< /hl-text >}}来计算**x、y**的**外积**。计算结果相当于一个$n \times 1$阶矩阵与一个$1 \times m$阶矩阵相乘，最终会生成一个$n \times m$阶的矩阵。

注意内积与外积算法同样也可以运用于矩阵、高纬数组，其规律与数组类似。计算内积时生成结果的维度等于两个参数中最大的维度，而计算外积时生成结果的维度等于两个参数的维度之和。

<br>

## 4.3、解矩阵方程

假设$XY = Z$，当矩阵**X、Z**已知时，我们可以通过{{< hl-text primary >}}solve{{< /hl-text >}}函数求解矩阵**Y**。如果**X**为上、下三角矩阵时，我们则可以分别使用{{< hl-text primary >}}backsolve、forwardsolve{{< /hl-text >}}函数求解**Y**。

假设$XY = YX = Z$, 其中**Z**为**单位矩阵**， 则**X、Y**互为**逆矩阵**。根据求解矩阵方程的规律，我们可以通过以下命令求解矩阵**X**的逆：`solve(X, diag(1, nrow(X)))`。

<br>

## 4.4、行列式
对于一个方阵**X**，我们可以使用{{< hl-text primary >}}det{{< /hl-text >}}函数来求解其**行列式**。注意矩阵的行列式可以写成以下形式：

$$det(X) = \sum (-1)^K * X\_{1k\_1} * X\_{2k\_2} * ... * X\_{nk\_n}$$

其中$k_1, k_2, ..., k_n$为数组**1:n**的一个排列，**K**为该排列中的逆序数。

<br>

## 4.5、特征值与特征向量

假设$Ax = \lambda x$，其中**A**为**方阵**，**x**为向量，$\lambda$为数字。则$\lambda$、**x**分别为矩阵**A**的**特征值**与**特征向量**（注意矩阵的特征值与特征向量可能不止有一个）。

在R语言中我们可以通过{{< hl-text primary >}}eigen{{< /hl-text >}}函数，来求解矩阵的特征值与特征向量。

```R
> eigen(cbind(c(1,-1), c(-1,1)))
eigen() decomposition
$values
[1] 2 0

$vectors
           [,1]       [,2]
[1,] -0.7071068 -0.7071068
[2,]  0.7071068 -0.7071068
```

注意这里显示的运算结果中：**$values**中每个值都是一个特征值，**$vectors**中每个一列都是一个特征向量，特征值与特征向量是一一对应的。

<br>

## 4.6、奇异值分解

假设$X = UDV^T$，其中**D**为**对角矩阵**，**U、V**均为由**单位向量**组成的方阵。则**D**中对角线上的元素为矩阵**X**的**奇异值**，**U、V**分别为矩阵**X**的**左、右奇异矩阵**。

在R语言中我们可以通过{{< hl-text primary >}}svd{{< /hl-text >}}函数，对矩阵进行奇异值分解。

```R
> svd(matrix(1:4, 2))
$d
[1] 5.4649857 0.3659662

$u
           [,1]       [,2]
[1,] -0.5760484 -0.8174156
[2,] -0.8174156  0.5760484

$v
           [,1]       [,2]
[1,] -0.4045536  0.9145143
[2,] -0.9145143 -0.4045536
```

注意这里显示的运算结果中：**$d**为**D**中对角线上的元素（奇异值），**$u、$v**分别对应**U、V**。

<br>

## 4.7、正交分解

对于一个方阵**A**，如果$AA^T = E$，其中**E**为**单位矩阵**，则称**A**为**正交矩阵**。

**正交分解**的过程，就是将一个矩阵**A**，分解为一个正交矩阵**Q**与一个上三角矩阵**R**的乘积，即$A = QR$。

在R语言中我们可以通过{{< hl-text primary >}}qr{{< /hl-text >}}函数，对矩阵进行正交分解。注意这里正交分解后生成的对象，以压缩数据的方式存储了计算结果，我们可以分别对其使用{{< hl-text primary >}}qr.Q、qr.R、qr.X{{< /hl-text >}}函数，来提取出其中的**Q、R**及原矩阵**A**。此外，R语言中定义了两个快捷函数{{< hl-text primary >}}qr.qy、qr.qty{{< /hl-text >}}，可以方便我们求解**Q**与其它矩阵的乘积。

$$\begin{cases}
  qr.qy(Q, Y) = QY \\\\ 
  qr.qty(Q, Y) = Q^TY
\end{cases}$$

正交分解对于求解多元方程组具有非常重要的意义。假设多元方程组$y = aX$，其中由自变量组成的矩阵**X**已知（或**X**的正交分解已知），由因变量组成的向量**y**已知。则我们可以分别对其使用{{< hl-text primary >}}qr.solve、qr.coef、qr.fitted、qr.resid{{< /hl-text >}}函数，求解多元方程、获取多元方程组的各项系数$a$
，获取拟合值$\hat y$，获取拟合误差$y - \hat y$。

<br>

## 4.8、三角分解

**三角分解**的过程，就是将一个矩阵**A**，分解为一个下三角矩阵**L**与一个上三角矩阵的乘积，即$A = L L^T$。在R语言中我们可以通过{{< hl-text primary >}}chol{{< /hl-text >}}函数，对矩阵进行三角分解，最终生成的结果是一个上三角矩阵。

三角分解对于矩阵求逆具有十分重要的意义。在R语言中我们可以对生成的上三角矩阵使用{{< hl-text primary >}}chol2inv{{< /hl-text >}}函数，来求解原矩阵的逆。

```R
chol_A <- chol(A  <- cbind(1, 1:3, c(1,3,7)))
> identical(A, t(chol_A) %*% chol_A)
[1] TRUE
> identical(diag(1, nrow(A)), chol2inv(chol_A) %*% A)
[1] TRUE
```

<br>

## 4.9、矩阵条件数、范数

矩阵的**条件数**、**范数**可以描述矩阵特某个特征（比如矩阵用于求解多项式系数时的可信度）。在R语言中我们可以分别通过{{< hl-text primary >}}kappa、rcond、norm{{< /hl-text >}}等函数，来求解这些值。

| 函数          | 替代命令                            | 说明                                            |
| :------------ | :-----------------------------------| :-----------------------------------------------|
| kappa(X)      | with(svd(X), max(d)/min(d))         | 条件数估计值，X的最大、最小奇异值之商           |
| rcond(X)      | 1/kappa(X)                          | 条件数倒数估计值                                |
| norm(X, "O")  | max(colSums(abs(X)))                | 按列汇总后的最大值                              |
| norm(X, "I")  | max(rowSums(abs(X)))                | 按行汇总后的最大值                              |
| norm(X, "M")  | max(abs(X))                         | X中的最大值                                     |
| norm(X, "2")  | max(svd(X)$d)                       | X的最大奇异值                                   |
| norm(X, "F")  | sqrt(sum(X^2))                      | X中各元素平方和的根                             |

<br>

# 5、结语

至此我们已经分别总结了R语言中如何对各种由数字组成的**数据对象**进行数学运算。当然R语言中还可以对一些其它类型的数据对象进行数学运算，这点我们会在之后总结相应的数据对象时介绍到。

{{< note "思考思考" "#e6e6ff" >}}
- 如何用矩阵解决**鸡兔同笼**问题？
- 根据上文提供的 [行列式计算公式](#-4.4-行列式)，计算一个n阶段方阵的行列式，需要进行多少次加（减）法的迭代运算？
- **rcond(X)**与**1/kappa(X)**之间存在的差异是计算误差吗？
{{< /note >}}

<br>
